# Техническое задание

Ура, практика! Пришло время усовершенствовать `Filmorate` с помощью полученных знаний о базах данных. На этот раз вы добавите ещё одну функциональность — сохранение состояния данных после перезапуска. Уже к концу задания у вас будет завершённое приложение для работы с фильмами и оценками пользователей. Внимание, мотор!

### Организация

В этом спринте вы будете работать в новой ветке. Назовите её `add-database`. Название ветки важно, потому что к ней привязаны тесты.

### Создание базы данных

В уроках спринта вы использовали PostgreSQL — популярную в индустрии базу данных. Однако сейчас вы будете работать с другой базой. Она называется **H2**. H2 не требует отдельной установки. Её можно встроить в приложение — достаточно добавить зависимость в сборку проекта. Использование встроенной базы данных упростит тестирование вашего приложения в GitHub.

База будет работать в двух режимах:

* В режиме тестирования H2 будет хранить данные в памяти. \*\*Это позволит базе быстро запуститься на время тестов и удалить все тестовые данные после их завершения.
* В рабочем режиме H2 будет хранить данные в файле на жёстком диске. Это не позволит рабочим данным потеряться между запусками.

Почитайте, как использовать H2 со Spring Boot, [в этой статье](https://www.baeldung.com/spring-boot-h2-database). Далее следуйте нашей инструкции:

1. Добавьте в проект зависимости `com.h2database.h2`, `org.springframework.boot.spring-boot-starter-data-jdbc` и `org.springframework.boot.spring-boot-starter-test`.
2. Сконфигурируйте базу данных для рабочего режима с помощью файла настроек `application.properties`.

```
spring.sql.init.mode=always
# в jdbc-url укажите, что данные нужно сохранять в файл
spring.datasource.url=jdbc:h2:file:./db/filmorate
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password 
```

3. Сформируйте структуру базы данных — для этого реализуйте схему, которую вы нарисовали в предыдущем спринте. Обратите внимание: база будет работать, пока работает само приложение. Чтобы подключиться к БД напрямую, используйте встроенный в IntelliJ IDEA функционал или клиент DBeaver.
4. Не забудьте обновить модели данных в коде — добавьте новые поля.
5. Соберите SQL-запросы, формирующие структуру вашей базы, в отдельный файл в `src/main/resources` с названием `schema.sql` — так схема будет создаваться заново при каждом запуске приложения.

### Подсказка: про файл schema.sql

Включите в файл `schema.sql` создание таблиц. Если вам нужны некоторые данные в базе, их инициализация обычно описывается в файле `data.sql` — создайте его там же, где и `schema.sql`.
Чтобы избежать ошибок, связанных с многократным применением скрипта к БД, добавьте условие `IF NOT EXISTS` при создании таблиц и индексов.

### Работа с DAO

Таблицы созданы. Теперь можно заняться кодом, который будет отвечать за получение данных из базы.

1. Вам пригодятся созданные ранее интерфейсы `UserStorage` и `FilmStorage`. Напишите для них новую имплементацию — например, `UserDbStorage` и `FilmDbStorage`. Эти классы будут DAO — объектами доступа к данным.
2. Напишите в DAO соответствующие мапперы и методы, позволяющие сохранять пользователей и фильмы в базу данных и получать их из неё.

### Подсказка: про аннотацию @Qualifier

Чтобы Spring мог работать с новыми компонентами и отличать их от старых хранилищ, воспользуйтесь аннотацией `@Qualifier`. Пример её использования можно найти [в этой статье](https://www.baeldung.com/spring-qualifier-annotation).

### Подсказка: как проверить, что база данных успешно настроена

Убедитесь, что ваше приложение работает с базой данных. Создайте новый фильм и пользователя, а потом перезапустите проект — данные должны сохраниться в базе и быть доступны после перезапуска.

### Подсказка: как реализовать CRUD-операции с использованием JdbcTemplate

В теме о работе с БД вы узнали, как делать выборку данных из базы с помощью SQL-запросов и `JdbcTemplate`. Для реализации методов, описанных в интерфейсах хранилищ, вам также потребуется добавлять новые данные и обновлять имеющиеся. Почитайте, как это сделать, [в этой статье](https://springframework.guru/spring-jdbctemplate-crud-operations/).

### Тестирование

Тестировать приложение вручную — трудоёмкий процесс, который сопряжён со многими ограничениями. Использовать Postman-запросы проще, но такой способ не позволяет протестировать имплементацию методов.

Вам предстоит реализовать **интеграционное тестирование** (англ. *integration testing*). С помощью него можно проверить работу приложения с зависимостями — например, с базой данных. Резидентная база данных обеспечит автономность ваших интеграционных тестов — перед каждым их запуском Spring будет создавать новую, чистую БД.

Подробнее об этом виде тестирования мы расскажем в следующем модуле, но простейшую его реализацию вы выполните уже сейчас.

```java
@SpringBootTest
@AutoConfigureTestDatabase
@RequiredArgsConstructor(onConstructor_ = @Autowired)
class FilmoRateApplicationTests {
    private final UserDbStorage userStorage;

    @Test
    public void testFindUserById() {

        Optional<User> userOptional = userStorage.findUserById(1);

        assertThat(userOptional)
                .isPresent()
                .hasValueSatisfying(user ->
                        assertThat(user).hasFieldOrPropertyWithValue("id", 1)
                );
    }
} 
```

Обратите внимание:

* по аннотации `@AutoConfigureTestDatabase` Spring понимает, что перед запуском теста необходимо сконфигурировать тестовую БД вместо основной;
* аннотация `@SpringBootTest`, которой помечается класс с тестами, говорит о том, что перед запуском этих тестов необходим запуск всего приложения;
* аргумент аннотации `@RequiredArgsConstructor` указывает, что конструктор, созданный с помощью библиотеки Lombok, сможет получать зависимости через механизм `@Autowired`.

Во время инициализации тестовой базы данных Spring прочитает SQL-запросы из стандартного файла `schema.sql`, который вы собрали в начале задания, и выполнит их для текущей базы данных. Этот скрипт должен создать схему в тестовой БД.

Теперь можно написать интеграционные тесты для DAO-объектов приложения по примеру выше. С помощью них вы проверите, правильно ли работают ваши запросы к базе данных. Убедитесь, что все публичные методы хранилища покрыты тестами.

### Доработка бизнес-логики

Осталось несколько штрихов. Добавьте в код недостающие DAO-объекты, соответствующие вашей схеме, и завершите описание бизнес-логики. После этого протестируйте поведение программы.

Поскольку в программе появились новые сущности, то нужно обеспечить доступ к ним. Добавьте следующие эндпоинты:

1. Для получения списка всех жанров и по идентификатору.

   ```
    GET /genres 
    GET /genres/{id}

    // Пример возвращаемого значения
    {
      “id”: 1,
      “name”: “Комедия”
    }

   ```
2. Для получения жанра и рейтинга по идентификатору:

   ```
    GET /mpa
    GET /mpa/{id}

    // Пример возвращаемого значения
    {
      “id”: 1,
      “name”: “G”
    }

   ```

При создании и получении фильмов достаточно передать список идентификаторов жанров и идентификатор рейтинга. Эти же данные должны передаваться при обновлении, создании и получении фильмов — если нужно, обновите эти эндпоинты.

И последнее небольше изменение: дружба должна стать односторонней. Это значит, что если какой-то пользователь оставил вам заявку в друзья, то он будет в списке ваших друзей, а вы в его — нет.

### Подсказка-напоминание

Не забудьте: у пользователей `Filmorate` должна быть возможность лайкать фильмы и добавлять друг друга в друзья с подтверждением дружбы.

### Финальный кадр

Убедитесь, что ваше приложение работает правильно. Проверьте его дополнительно с помощью тестов Postman: [sprint.json](https://github.com/yandex-praktikum/java-filmorate/blob/add-database/postman/sprint.json).

⚠️ Эти же тесты запускаются в GitHub при создании pull request’а. Проверьте их локально, прежде чем делать pull request.

Поздравляем! У вас получилось полноценное приложение, которое умеет обрабатывать и хранить данные о пользователях и их любимых фильмах. Выбрать что-нибудь для просмотра за ужином больше не составит труда. Вы снова на высоте. Хеппи-энд и титры!

![img1.png](assets/img1.png)
